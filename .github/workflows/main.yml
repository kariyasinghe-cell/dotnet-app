name: STG Env - CD Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

  push:
    # branches:
    #   - 'release/*'
    #   - 'feature/stg-cd-integration'
    #   - 'feature/api-automation'
    # tags:
    #   - 'v*.*.*'

jobs:

  fetch-repo-topics:
    name: Fetch Repository Topics
    runs-on: ubuntu-latest
    outputs:
      topics_status: ${{ steps.check_topics.outputs.topic_status }}
    steps:

      - name: Debug API Response
        run: |
          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/topics \
            -H "Accept: application/vnd.github.mercy-preview+json")
          echo "API Response: $RESPONSE"

      - name: Fetch Repository Topics
        id: check_topics
        run: |
          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/topics \
            -H "Accept: application/vnd.github.mercy-preview+json")
          echo "API Response: $RESPONSE"

          REPO_TOPICS=$(echo "$RESPONSE" | jq -r '.names | join(" ")')
          echo "Repository Topics: $REPO_TOPICS"

          TOPIC_STATUS="new"
          if [[ "$REPO_TOPICS" == *"active"* ]]; then
            TOPIC_STATUS="active"
          elif [[ "$REPO_TOPICS" == *"maintenance"* ]]; then
            TOPIC_STATUS="maintenance"
          elif [[ "$REPO_TOPICS" == *"deprecated"* ]]; then
            TOPIC_STATUS="deprecated"
          elif [[ "$REPO_TOPICS" == *"decommissioned"* ]]; then
            TOPIC_STATUS="decommissioned"
          fi

          echo "Determined Topic Status: $TOPIC_STATUS"
          echo "topic_status=$TOPIC_STATUS" >> $GITHUB_OUTPUT

  # copyright-check:
  #   name: Copyright Headers Check
  #   permissions:
  #     contents: read
  #     packages: read
  #   env:
  #     GITHUB_ACTOR: ${{ secrets.COMMON_USER }}
  #     GITHUB_TOKEN: ${{ secrets.COMMON_USER_TOKEN }}
  #   runs-on: ubuntu-latest
  #   needs: fetch-repo-topics
  #   continue-on-error: true
  #   outputs:
  #     copyright_failed: ${{ steps.set_output.outputs.failed }}
  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Fetch Centralized Licenserc File
  #       run: |
  #         git clone https://x-access-token:${{ secrets.COMMON_USER_TOKEN }}@github.com/sampathbankplc/pipeline-config.git pipeline-configs
  #         cp pipeline-configs/centralized-configs/.licenserc.yaml .github/.licenserc.yaml

  #     - name: Check copyright header
  #       id: check
  #       uses: apache/skywalking-eyes/header@v0.7.0
  #       continue-on-error: true
  #       with:
  #         config: .github/.licenserc.yaml
  #         mode: check

  #     - name: Set Output for Copyright Check
  #       id: set_output
  #       run: |
  #         if [[ "${{ steps.check.outcome }}" == "failure" ]]; then
  #           echo "failed=true" >> $GITHUB_OUTPUT
  #           exit 1
  #         else
  #           echo "failed=false" >> $GITHUB_OUTPUT
  #         fi

  code-formatting-check:
    name: Code Formatting Check
    runs-on: ubuntu-latest
    needs: fetch-repo-topics
    continue-on-error: true
    outputs:
      formatting_failed: ${{ steps.set_output.outputs.failed }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.305'

      - name: Restore dependencies
        run: dotnet restore

      - name: Run Format Check
        continue-on-error: true
        id: format
        run: dotnet format --verify-no-changes


      - name: Set Output for Code Formatting Check
        id: set_output
        run: |
          if [[ "${{ steps.spotless.outcome }}" == "failure" ]]; then
            echo "failed=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

  prepare-workspace:
    name: Prepare Build Workspace
    runs-on: ubuntu-latest
    outputs:
      workspace-path: ${{ steps.define_workspace.outputs.workspace }}

    steps:
      - name: Define Workspace
        id: define_workspace
        run: |
          WORKSPACE="${{ github.workspace }}/${{ github.run_id }}-ci"
          mkdir -p "$WORKSPACE"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT
          echo "WORKSPACE=$WORKSPACE" >> $GITHUB_ENV

      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          clean: true
          path: ${{ env.WORKSPACE }}
          fetch-depth: 0

  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: prepare-workspace
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.305'

      - name: Verify dotnet Version
        working-directory: ${{ github.WORKSPACE }}
        run: |
          dotnet --version

      - name: Build, Test and Generate Coverage
        working-directory: ${{ github.WORKSPACE }}
        env:
          http_proxy: http://192.168.5.60:8080
          https_proxy: http://192.168.5.60:8080
        run: |
          dotnet clean
          dotnet restore --no-cache
          dotnet build --no-restore --configuration Release
          dotnet test --no-build --configuration Release --collect:"XPlat Code Coverage"
          
  sonarqube-quality-gate-check:
    name: SonarQube Quality Check
    runs-on: [ self-hosted, linux ]
    needs:
      - fetch-repo-topics
      - prepare-workspace
      # - copyright-check
      - code-formatting-check
      - build-and-test
    if: ${{ needs.fetch-repo-topics.outputs.topic_status != 'new' ||
      (needs.fetch-repo-topics.outputs.topic_status == 'new' &&
      needs.copyright-check.outputs.copyright_failed == 'false' &&
      needs.code-formatting-check.outputs.formatting_failed == 'false') }}

    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
    steps:
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Verify Java Version for Sonar
        working-directory: ${{ env.WORKSPACE }}
        run: |
          java -version

      - name: SonarQube Scan - Quality Gate Check
        working-directory: ${{ env.WORKSPACE }}
        run: |
          REPO_NAME=$(basename $GITHUB_REPOSITORY)
          SONAR_PROJECT_KEY="$REPO_NAME"
          echo "Using Sonar project key: $SONAR_PROJECT_KEY"
          
          mvn sonar:sonar -X \
            -Dsonar.host.url=http://192.168.129.211:9999 \
            -Dsonar.token=${{ secrets.SONAR_QUBE_TOKEN }} \
            -Dhttp.proxyHost=192.168.5.60 -Dhttp.proxyPort=8080 \
            -Dhttps.proxyHost=192.168.5.60 -Dhttps.proxyPort=8080 \
            -Dhttp.nonProxyHosts="localhost|127.0.0.1|192.168.129.211" \
            -Dhttps.nonProxyHosts="localhost|127.0.0.1|192.168.129.211" \
            -Dsonar.projectKey=$SONAR_PROJECT_KEY \
            -Dsonar.projectName=$SONAR_PROJECT_KEY \
            -Dsonar.projectVersion=${{ github.sha }} \
            -Dsonar.scm.provider=git \
            -Dsonar.scm.forceReloadAll=true \
            -Dsonar.qualitygate.wait=true

  fortify-vulnerability-scan:
    name: Fortify Vulnerability Scan
    runs-on: [ self-hosted, linux ]
    needs:
      - fetch-repo-topics
      - prepare-workspace
      # - copyright-check
      - code-formatting-check
      - build-and-test
    if: ${{ needs.fetch-repo-topics.outputs.topic_status != 'new' ||
      (needs.fetch-repo-topics.outputs.topic_status == 'new' &&
      needs.copyright-check.outputs.copyright_failed == 'false' &&
      needs.code-formatting-check.outputs.formatting_failed == 'false') }}
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - name: Run Fortify on Demand SAST & SCA Scan
        run: echo "Fortify scan logic goes here"
#        uses: fortify/github-action@v2
#        with:
#          sast-scan: true
#          debricked-sca-scan: true
#          build-command: cd ${{ env.WORKSPACE }} && mvn clean package
#          release-id: ${{ secrets.FOD_RELEASE_ID }}
#        env:
#          FOD_URL: https://ams.fortify.com
#          FOD_TENANT: Mitra_945180077_FMA_408016995
#          FOD_CLIENT_ID: 081f768a-9700-4621-8ed3-8aff17832c62
#          FOD_CLIENT_SECRET: c1k1UllmbUtPMmRpZWAyZDBZVU5ZRztBSSppTGg50

  artifact-processing:
    name: "Artifact Packaging"
    runs-on: [ self-hosted, linux ]
    needs:
      - prepare-workspace
      - fortify-vulnerability-scan

    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - name: Artifact Packaging
        working-directory: ${{ env.WORKSPACE }}
        run: |
          mvn -B clean package -DskipTests \
            -Dhttp.proxyHost=192.168.5.60 \
            -Dhttp.proxyPort=8080 \
            -Dhttps.proxyHost=192.168.5.60 \
            -Dhttps.proxyPort=8080

      - name: Artifact Publishing
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo "No artifacts to publish"

  pre-deploy-notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs:
      - prepare-workspace
      - fetch-repo-topics
      # - copyright-check
      - code-formatting-check
      - build-and-test
      - fortify-vulnerability-scan
      - artifact-processing
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

    steps:
      - name: Notify Deployment Status
        run: |
          set -euo pipefail
          TITLE=""
          COLOR=""
          PASSED_JOBS=""
          FAILED_JOBS=""
          SKIPPED_JOBS=""
          OPTIONAL_FAILED_JOBS=""

          prettify() {
            sed -E 's/([a-z])([A-Z])/\1 \2/g' <<< "$1"
          }

          pad_right() {
            printf "%-30s" "$1"
          }

          NEEDS_JSON='${{ toJson(needs) }}'
          TOPIC_STATUS="${{ needs.fetch-repo-topics.outputs.topic_status }}"

          echo "Fetching job results..."
          for job in $(jq -r 'keys[]' <<< "$NEEDS_JSON"); do
            RESULT=$(jq -r ".\"$job\".result" <<< "$NEEDS_JSON")
            JOB_NAME=$(prettify "$job")
            PADDED_JOB_NAME=$(pad_right "$JOB_NAME")

            if [[ "$job" == "copyright-check" ]]; then
              COPYRIGHT_FAILED="${{ needs.copyright-check.outputs.copyright_failed }}"
              echo "Copyright Check Output: $COPYRIGHT_FAILED"
              if [[ "$COPYRIGHT_FAILED" == "true" ]]; then
                if [[ "$TOPIC_STATUS" != "new" ]]; then
                  OPTIONAL_FAILED_JOBS+="- ❌ $PADDED_JOB_NAME\n"
                  continue
                fi
                RESULT="failure"
              fi
            elif [[ "$job" == "code-formatting-check" ]]; then
              FORMATTING_FAILED="${{ needs.code-formatting-check.outputs.formatting_failed }}"
              echo "Code Formatting Check Output: $FORMATTING_FAILED"
              if [[ "$FORMATTING_FAILED" == "true" ]]; then
                if [[ "$TOPIC_STATUS" != "new" ]]; then
                  OPTIONAL_FAILED_JOBS+="- ❌ $PADDED_JOB_NAME\n"
                  continue
                fi
                RESULT="failure"
              fi
            fi

            if [[ "$RESULT" == "success" ]]; then
              PASSED_JOBS+="- ✅ $PADDED_JOB_NAME\n"
            elif [[ "$RESULT" == "failure" ]]; then
              FAILED_JOBS+="- ❌ $PADDED_JOB_NAME\n"
            else
              SKIPPED_JOBS+="- ⚠️ $PADDED_JOB_NAME\n"
            fi
          done

          if [[ -z "$FAILED_JOBS" && -z "$SKIPPED_JOBS" ]]; then
            TITLE="✅ Pre-Deployment Verification: Success | Deployment Ready"
            COLOR="2E8B57"
          else
            TITLE="❌ Pre-Deployment Verification: Failed | Deployment Blocked"
            COLOR="B22222"
          fi

          FACTS="[ \
            {\"name\":\"📋 Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"🌿 Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"🔗 Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"👤 Initiated By:\", \"value\":\"${{ github.actor }}\"}, \
            {\"name\":\"📌 Project Category:\", \"value\":\"$TOPIC_STATUS\"}"

          [[ -n "$PASSED_JOBS" ]] && FACTS+=", {\"name\":\"✅ Passed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$PASSED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$FAILED_JOBS" ]] && FACTS+=", {\"name\":\"❌ Failed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$FAILED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$SKIPPED_JOBS" ]] && FACTS+=", {\"name\":\"⚠️ Skipped Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$SKIPPED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$OPTIONAL_FAILED_JOBS" ]] && FACTS+=", {\"name\":\"❌ Failed (Optional)\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$OPTIONAL_FAILED_JOBS" | sed 's/"/\\"/g')\"}"

          FACTS+="]"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              }
            ]
          }
          EOF
          )

          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL }}"

  deploy:
    name: "Deploy Application"
    runs-on: ubuntu-latest
    needs:
      - prepare-workspace
      - artifact-processing
    environment: ${{ github.events.inputs.environment }}
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
    outputs:
      context-path: ${{ steps.deploy-war.outputs.context-path }}

    steps:
      - name: Set Tomcat Host Environment
        run: |
          echo "TOMCAT_HOST=${{ secrets.STG_TOMCAT_HOST }}" >> $GITHUB_ENV
          echo "SCRIPT_MANAGER_USER=${{ secrets.STG_TOMCAT_SCRIPT_MANAGER_USER }}" >> $GITHUB_ENV
          echo "SCRIPT_MANAGER_PASSWORD=${{ secrets.STG_TOMCAT_SCRIPT_MANAGER_PASSWORD }}" >> $GITHUB_ENV

      - name: Deploy WAR via Tomcat Manager
        working-directory: ${{ env.WORKSPACE }}
        id: deploy-war
        run: |
          WAR_FILE=$(find target -name "*.war" | head -n 1)
          if [ -z "$WAR_FILE" ]; then
            echo "WAR file not found!"
            exit 1
          fi
          
          WAR_NAME=$(basename "$WAR_FILE")
          CONTEXT_PATH="${WAR_NAME%.war}"
          
          echo "Deploying $WAR_NAME to Tomcat ($TOMCAT_HOST) at context path $CONTEXT_PATH..."
          curl -v --noproxy "*" \
            --fail \
            --header "Expect:" \
            --upload-file "$WAR_FILE" \
            -u "$SCRIPT_MANAGER_USER:$SCRIPT_MANAGER_PASSWORD" \
            "http://$TOMCAT_HOST:8080/manager/text/deploy?path=/$CONTEXT_PATH&update=true"
          
          echo "context-path=$CONTEXT_PATH" >> $GITHUB_OUTPUT

  post-deployment-verify:
    name: Post Deployment Verification
    runs-on: ubuntu-latest
    needs:
      - deploy
      - pre-deploy-notify
    env:
      CONTEXT_PATH: ${{ needs.deploy.outputs.context-path }}
      TOMCAT_HOST: ${{ secrets.STG_TOMCAT_HOST }}
      SCRIPT_MANAGER_USER: ${{ secrets.STG_TOMCAT_SCRIPT_MANAGER_USER }}
      SCRIPT_MANAGER_PASSWORD: ${{ secrets.STG_TOMCAT_SCRIPT_MANAGER_PASSWORD }}

    steps:
      - name: Verify Deployment Is Running
        run: |
          for attempt in {1..20}; do
            echo "Attempt $attempt: Checking deployment status..."

            STATUS=$(curl --noproxy "*" -s -u "$SCRIPT_MANAGER_USER:$SCRIPT_MANAGER_PASSWORD" \
              "http://$TOMCAT_HOST:8080/manager/text/list")

            if echo "$STATUS" | grep -qE "/$CONTEXT_PATH:running:[0-9]+:$CONTEXT_PATH"; then
              echo "Deployment is running successfully."
              exit 0
            fi

            echo "Application not running yet. Retrying in 10 seconds..."
            sleep 10
          done

          echo "Deployment failed or checking timed out after 20 attempts."
          exit 1

  smoke-test-verification:
    name: Smoke Test Verification
    runs-on: ubuntu-latest
    needs:
#      - prepare-workspace
      - post-deployment-verify
#    env:
#      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
#    container:
#      image: mcr.microsoft.com/playwright:v1.47.2-focal
#      options: --ipc=host

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Install dependencies
        run: npm ci
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke

      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke

      - name: Run Playwright Smoke Tests
        run: npx playwright test
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/smoke

       # Alternative Docker-based approach
#      - name: Run tests
#        run: |
#          docker run -rm \
#          --ipc=host \
#          --network=host \
#          --user pwuser \
#          -v ${{ env.WORKSPACE }}:/ workspace \
#          -w /workspace/tests/automation/e2e/smoke \
#          mcr.microsoft.com/playwright:v1.55.0-noble \
#          sh -c "npm ci && npx playwright test"

  regression-test-verification:
    name: Regression Test Verification
    runs-on: ubuntu-latest
    needs:
#      - prepare-workspace
      - post-deployment-verify
      - smoke-test-verification
#    env:
#      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Install dependencies
        run: npm ci
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression

      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression

      - name: Run Playwright Regression Tests
        run: npx playwright test
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression
        working-directory: ${{ env.WORKSPACE }}/tests/automation/e2e/regression

  api-automation-verification:
    name: API Automation Verification
    runs-on: ubuntu-latest
    needs:
#      - prepare-workspace
      - post-deployment-verify
      - smoke-test-verification
      - regression-test-verification
#    env:
#      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - uses: actions/checkout@v4

      - name: Install Postman CLI
        run: |
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh

      - name: Authenticate Postman CLI
        run: |
          postman login --with-api-key ${{ secrets.POSTMAN_API_KEY }}

      - name: Run Postman Collection
        run: |
          set -euo pipefail

          collections=$(find postman -type f -name "*.postman_collection.json")
          
          if [ -z "$collections" ]; then
            echo "No Postman collection files found."
            exit 1
          fi

          for collection in $collections; do
            echo "Running collection: $collection"
            postman collection run "$collection" --bail --verbose || {
              echo "Collection failed: $collection"
              exit 1
            }
          done
#        working-directory: ${{ env.WORKSPACE }}/tests/automation/api/functional
        working-directory: ${{ env.WORKSPACE }}/tests/automation/api/functional

  post-deploy-notify:
    name: Notify After Deployment
    runs-on: ubuntu-latest
    needs:
      - fetch-repo-topics
      - post-deployment-verify
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

    steps:
      - name: Notify Deployment Completion
        run: |
          set -euo pipefail
          TITLE="🎉 Deployment Completed Successfully!"
          COLOR="2E8B57"
          STATUS="✅ Success"
          
          if [[ "${{ needs.post-deployment-verify.result }}" != "success" ]]; then
            TITLE="❌ Deployment Failed"
            COLOR="B22222"
            STATUS="🚨 Failed"
          fi
          
          TOPIC_STATUS="${{ needs.fetch-repo-topics.outputs.topic_status }}"
          
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": [
                  {"name": "🚀 Deployment Status:", "value": "$STATUS"},
                  {"name": "📋 Workflow:", "value": "${{ github.workflow }}"},
                  {"name": "🌿 Branch:", "value": "${{ github.ref_name }}"},
                  {"name": "🔗 Commit:", "value": "${{ github.sha }}"},
                  {"name": "👤 Initiated By:", "value": "${{ github.actor }}"},
                  {"name": "📌 Project Category:", "value": "$TOPIC_STATUS"}
                ]
              }
            ]
          }
          EOF
          )
          
          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL }}"

  cleanup-workspace:
    name: Cleanup Workspace
    runs-on: [ self-hosted, linux ]
    needs:
      - prepare-workspace
      - build-and-test
      - fortify-vulnerability-scan
      - artifact-processing
      - deploy
      - post-deployment-verify
      - smoke-test-verification
      - regression-test-verification
      - api-automation-verification
    if: always()
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}

    steps:
      - name: Cleanup Workspace
        run: |
          echo "Cleaning up workspace..."
          rm -rf "${{ env.WORKSPACE }}"
